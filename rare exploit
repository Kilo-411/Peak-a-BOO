#include "libc_less.c.inc"

static unsigned long syscall_addr;

static long do_remote_syscall(int pid, struct user_pt_regs *syscall_regs) {
	injectlib_stdout_write("performing remote syscall\n");
	syscall_regs->pc = syscall_addr;
	struct iovec sysc_regs_vec = { .iov_base = syscall_regs, .iov_len = sizeof(*syscall_regs) };
	// write back registers
	int srs_ret = injectlib_ptrace(PTRACE_SETREGSET, pid, (void*)NT_PRSTATUS, &sysc_regs_vec);
	if (srs_ret) {
		injectlib_stdout_write("PTRACE_SETREGSET failed\n");
		while (1) {} /* fatal error */
	}

	// step into and out of the syscall
	int ptrace_res = injectlib_ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
	if (ptrace_res) {
		injectlib_stdout_write("PTRACE_SYSCALL(1) failed\n");
		while (1) {} /* fatal error */
	}
	injectlib_simple_wait(pid);
	ptrace_res = injectlib_ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
	if (ptrace_res) {
		injectlib_stdout_write("PTRACE_SYSCALL(2) failed\n");
		while (1) {} /* fatal error */
	}
	injectlib_simple_wait(pid);

	int grs_ret = injectlib_ptrace(PTRACE_GETREGSET, pid, (void*)NT_PRSTATUS, &sysc_regs_vec);
	if (grs_ret) {
		injectlib_stdout_write("PTRACE_GETREGSET failed\n");
		while (1) {} /* fatal error */
	}

	injectlib_stdout_write("remote syscall done: ");
	injectlib_log_hexnum(syscall_regs->regs[0]);
	injectlib_stdout_write("\n");
	return syscall_regs->regs[0];
}
